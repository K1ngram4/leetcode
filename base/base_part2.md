## 算法复杂度及渐进符号
复杂度有两个维度：时间和空间。

每个程序运行过程中，都要占用一定的计算机资源，比如内存，磁盘等，这些是空间
计算过程中需要判断，循环执行某些逻辑，周而反复，这些是时间

我们说，一个实现了某算法的程序：
- 如果计算的速度越快，那么这个算法时间复杂度越低。
- 如果占用的计算资源越少，那么空间复杂度越低。

## 算法规模
我们要计算公式 1 + 2 + 3 + ... + 100，那么按照最直观的算法来写：
```go
package main
import "fmt"
func sum(n int) int {
    total := 0
    // 从1加到N, 1+2+3+4+5+..+N
    for i := 1; i <= n; i++ {
        total = total + i
    }
    return total
}
func main() {
    fmt.Println(sum(100))
}
```
当` n = 10 `时就等于我们要计算的公式。这个算法要循环` n-1 `次，当 n 很小时，计算很快，但当 n 无限大的时候，计算很慢。
所以，算法衡量要衡量的是在不同问题规模 n 下，算法的速度。

在这里，因为要循环计算` n-1 `次，而当 n 无限大时，常数项基本忽略不计，所以这个算法的时间复杂度，我们用` O(n) `来表示。

我们有另外一种计算方式：

```go
func sum2(n int) int {
    total := ((1 + n) * n) / 2
    return total
}
```
这次算法只需执行 1 次，所以这个算法的时间复杂度是 `O(1)`。可以看出，时间复杂度为 `O(1) `的算法优于复杂度为 `O(n) `的算法。

当然，还有指数级别的比如之前的汉诺塔算法，对数级别的，阶乘级别的复杂度，如 O(2^n)，O(n!)，O(logn) 等。

算法的优先级排列如下，一般排在上面的要优于排在下面的：
- 常数复杂度：O(1)
- 对数复杂度：O(logn)
- 一次方复杂度：O(n)
- 一次方乘对数复杂度：O(nlogn)
- 乘方复杂度：O(n^2)，O(n^3)
- 指数复杂度：O(2^n)
- 阶乘复杂度：O(n!)
- 无限大指数复杂度：O(n^n)

如何量化一个复杂度，到底有多复杂，计算机科学抽象出了几个复杂度渐进符号。

O，ο，Θ，Ω，ω

分别读作：Omicron（大欧），omicron（小欧），Theta（西塔），Omega（大欧米伽），omega（小欧米伽）。

我们一般用 O 渐进上界来评估一个算法的时间复杂度，表示逼近的最坏情况。其他渐进符合基本不怎么使用。