## 1、什么是算法

算法在计算机科学中可以描述为：计算机接收一个输入指令，然后进行一个过程处理，最后输出计算的结果。

算法是一种`有限，确定，有效`的并适合用计算机程序来实现的，用来解决问题的方法。首先，有一个问题，然后有一个方法去解决它，这个方法叫算法。

- 算法是有限的，就是算法的步骤是有限的，执行的时间也是有限的，能够在有限时间内得出结果。

- 算法是确定的，就是无论执行多少次，计算得出的结果都一样。

- 算法是有效的，就是计算出的结果对解决问题有帮助。

汉诺塔问题：

有三根杆子（A,B,C），在A杆自下而上、由大到小按顺序放置64个金盘

**游戏目标**：把A杆上的金盘全部移到C杆上，并仍然保持原有顺序叠好。

**规则**：每次只能移动一个金盘，且任何时候三根杆子上都是大盘在下，小盘在上的状态

最简单的算法：
- 首先借助`C`杆，将`A`杆前`N-1`个盘子移动到`B`杆上，再将`A`杆上的最后一个杆子移动到`C`杆
- 然后借助`A`杆，将`B`杆前`N-1`个盘子移动到`C`杆上，就完成了。

程序代码：
```go
/*
	第一步，把n-1个盘子从A杆子上移动到B杆子上
	第二步，把第n个盘子移动到C杆子上
	第三步，把n-1个盘子从B杆子上移动到C杆子上
 */
func tower(n int, a, b, c string) {
	//第二步，把第n个盘子移动到C杆子上
	if n == 1 {
		total = total + 1
		fmt.Println(a, "->", c)
		return
	}
	//第一步，把n-1个盘子从A杆子上移动到B杆子上
	tower(n-1, a, c, b)
	total = total + 1
	fmt.Println(a, "->", c)
	//第三步，把n-1个盘子从B杆子上移动到C杆子上
	tower(n-1, b, a, c)
	return
}
```
## 2、什么是数据结构
数据结构，顾名思义就是存放数据的结构或者容器，比如你要从1000个数字中找到一个最大值，首先你要将1000个数字记录在某些卡片上。

大多数算法都需要组织数据，所以就产生了数据结构，基本的数据结构有：链表，栈和队列，树和图。

## 3、什么是好的数据结构和好的算法
好的算法可以节约资源，但是选择合适的算法很难。我们要进行复杂的数学分析才能知道，什么叫做好的，在计算机里，我们把这种数学分析这叫做算法分析。
- 占用资源越少的算法越好
- 越快执行完毕的算法越好

因此出现了一个理论：时间和空间算法复杂度理论

程序执行过程中，要么空间换时间，要么时间换空间，空间可以认为是一种计算机资源如内存使用情况，而时间是人类感知的第四个维度，就是慢还是快，两者一般不能兼得，如果发现居然兼得了，那就是发明了一种更好的算法。

## 4、分治法和递归
分治法就是把一个复杂的问题分成两个或更多的相同或相似的子问题。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。一般使用递归来求问题的解。

递归就是不断的调用自身，例如：求阶乘`1 * 2 * 3 * 4 * ... * n`

程序代码：

```go
/*
	求阶乘 1 * 2 * 3 * 4 * ... * n
 */
func recursion(n int) int {
	if n ==  0 {
		return 1
	}
	return n * recursion(n - 1)
}
```

这种计算方式我们在调用自身的同时还乘以了一个变量n，因此每次执行时都使得运算的链条不断加长，就需要使用栈内存进行数据保存。

在递归次数非常大的时候可能会导致栈内存溢出，程序崩溃。

所以有另外一种写法，叫做**尾递归**，去掉每次递归中的运算过程。

程序代码：

```go
/*
	尾部调用，每次调用时把值计算后传入，减少函数过程中的运算
 */
func recursionTail(n ,a int) int {
	if n ==  0 {
		return a
	}
	return recursionTail(n-1,a * n)
}
```

**斐波那契数列**

斐波那契数列是指，后一个数是前两个数的和的一种数列。如下：

```
1 1 2 3 5 8 13 21 ... N-1 N 2N-1
```

求第n个值，这里也用到了尾递归

程序代码：

```go
/*
	求斐波那契数列中第n的值
	1 1 2 3 5 8 13 21 ... N-1 N 2N-1
 */
func f(n ,a1 , a2 int) int {
	if n == 1 {
		return a1
	}
	return f(n-1,a2,a1+a2)
}
```

**二分法**

在已经排好序的数列中，找到某个数

二分法的思路就是拿出数列中的中位数与某个数比较，如果匹配到了就结束

否则因为是排好序的队列，要么在左边要么在右边，这种一分为二的查找叫做二分查找算法。

程序代码：

```go
/*
	BinarySearch 二分查找递归解法
	l : 左边下标
	r : 右边下标
	target： 要找到的数
 */
func BinarySearch(array []int, target int, l, r int) int {
	if l > r {
		// 出界了，找不到
		return -1
	}
	// 从中间开始找
	mid := (l + r) / 2
	middleNum := array[mid]
	if middleNum == target {
		return mid // 找到了
	} else if middleNum > target {
		// 中间的数比目标还大，从左边找
		return BinarySearch(array, target, 1, mid-1)
	} else {
		// 中间的数比目标还小，从右边找
		return BinarySearch(array, target, mid+1, r)
	}
}
```

